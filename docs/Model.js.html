<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Model.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Model.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import fs from "fs";
import DeepSave from "./DeepSave.js";
import { validate } from "./Validator.js";

/**
 * Represent a model of data, with many method to manage data storage.
 * This is build from jdb.define, based on a schema.
 * @class Model
 * @constructor
 */
class Model {
    /**
     * Model constructor, this class should not be instanciate directly, but called through jdb.define
     * @param {string} name the name of the data to store (table name)
     * @param {Object} schema the validation schema with table properties and options
     * @param {string} [namespace] the path to the folder where data should be stored (default /data)
     * @param {number} [deepSaveTiming] timing in milliseconds between two automatic deepSave (default 5 minutes)

     */
    constructor(name, schema, { namespace, deepSaveTiming = 1000 * 60 * 5 }) {
        /**
         * @private
         */
        this.name = name;
        /**
         * @private
         */
        this.schema = schema;
        /**
         * @private
         */
        this.filename = name + ".json";
        /**
         * @private
         */
        this.logname = name + ".txt";
        /**
         * @private
         */
        this.namespace = namespace;
        /**
         * @private
         */
        this.deepSaveTiming = deepSaveTiming;
        /**
         * @private
         */
        this.deepSave = new DeepSave(this.logname, this.filename, this.name, this.namespace);
        if (!fs.existsSync("./" + this.namespace + "/" + this.filename)) {
            /**
             * @private
             */
            this.data = [];
            fs.writeFileSync("./" + this.namespace + "/" + this.filename, "[]", { flag: "a+" });
        } else {
            this.data = JSON.parse(fs.readFileSync("./" + this.namespace + "/" + this.filename, { flag: "a+" }));
        }
        if (!fs.existsSync("./" + this.namespace + "/history/" + this.logname)) {
            fs.writeFileSync("./" + this.namespace + "/history/" + this.logname, "", { flag: "a+" });
        }
        this.deepSaveLauncher();
        /**
         * @private
         */
        this.currentId = this.data.length > 0 ? Math.max(...this.data.map(u => u.id)) : 0;
    }
    /**
     * Launch the deepSave function to store all history operation in json data file
     */
    flush() {
        this.deepSave.save();
    }

    /**
     * Add operation in history for storage
     * @param {string} operation type of crud operation to add in history
     * @param {*} data data related to the operation
     * @private
     */
    save(operation, data) {
        try {
            fs.appendFileSync("./" + this.namespace + "/history/" + this.logname, operation + " " + JSON.stringify(data) + "\n");
        } catch (e) {
            throw new Error(e.message);
        }
    }

    /**
     * Method to launch auto-save of history into json files
     * @private
     */
    deepSaveLauncher() {
        setTimeout(() => {
            this.deepSave.save();
            this.deepSaveLauncher();
        }, this.deepSaveTiming);
    }

    /**
     * Read query to get all element of a model.
     * @param {Object} options various filtering options
     * @returns All elements matching filtering conditions
     */
    findAll(options) {
        if (!options.where &amp;&amp; this.data.length > 0) {
            return this.data;
        }
        return this.data.filter(element => this.checkWhereClause(element, options));
    }

    /**
     * Read query to get the first element of a model.
     * @param {Object} options various filtering options
     * @returns First element matching filtering conditions
     */
    findOne(options) {
        if (!options.where &amp;&amp; this.data.length > 0) {
            return this.data[0];
        }
        return this.data.find(element => this.checkWhereClause(element, options));
    }

    /**
     * Create query to insert an element into the database
     * @param {Object} element the element to store
     * @returns the element after created
     * @throws Error may be throw if the element does not pass all schema validation conditions
     */
    create(element) {
        try {
            let errorStack = [];
            this.addDefaultValue(element);
            errorStack = errorStack.concat(this.checkFieldExist(element));
            errorStack = errorStack.concat(this.checkFormat(element));
            errorStack = errorStack.concat(this.checkRequired(element));
            errorStack = errorStack.concat(this.checkValidator(element));
            if (errorStack.length > 0) {
                throw new Error("Validation failed", { cause: errorStack });
            }
        } catch (e) {
            throw e;
        }

        const newElement = {
            ...element,
            id: this.currentId + 1
        };
        this.data.push(newElement);
        try {
            this.save("add", newElement);
            this.currentId++;
        } catch (e) {
            this.data.pop();
            throw new Error(e.message);
        }

        return newElement;
    }

    /**
     * Update query to update an element into the database
     * @param {Object} element the element to update
     * @param {Object} options various filtering options
     * @returns the element after update
     * @throws Error may be throw if the element does not pass all schema validation conditions
     */
    updateOne(element, options) {
        let elementToUpdate = this.findOne(options);
        let copy = structuredClone(elementToUpdate);
        Object.assign(elementToUpdate, element);
        try {
            let errorStack = [];
            errorStack = errorStack.concat(this.checkFieldExist(elementToUpdate));
            errorStack = errorStack.concat(this.checkFormat(elementToUpdate));
            errorStack = errorStack.concat(this.checkRequired(elementToUpdate));
            errorStack = errorStack.concat(this.checkValidator(elementToUpdate));
        } catch (e) {
            throw e;
        }
        try {
            this.save("update", elementToUpdate);
            return elementToUpdate;
        } catch (e) {
            elementToUpdate = copy;
            throw new Error(e.message);
        }
    }

    /**
     * Delete query to remove one or many elements from the database
     * @param {Object} options various filtering options
     * @returns number of deleted elements
     * @throws Error may be throw if the deletion failed
     */
    destroy(options) {
        if (!options.where &amp;&amp; this.data.length > 0) {
            return 0;
        }
        let count = this.data.length;
        const dataToDelete = this.findOne(options);
        this.data = this.data.filter(user => !checkWhereClause(user, options));
        try {
            this.save("delete", dataToDelete);
        } catch (e) {
            this.data.push(dataToDelete);
            throw new Error(e.message);
        }
        return count - this.data.length;
    }

    /**
     * Check all where query constraint on one element
     * @param {Object} element the element to check
     * @param {Object} options various filtering options
     * @returns true if the element passed all conditions, either false
     * @private
     */
    checkWhereClause(element, options) {
        for (let [field, value] of Object.entries(options.where)) {
            if (value.like) {
                if (!this.checkLikeClause(element[field], value.like)) {
                    return false;
                }
            }
            else if (value.in) {
                if (!this.checkInClause(element[field], value.in)) {
                    return false;
                }
            }
            else if (element[field] !== value) {
                return false;
            }
        }
        return true;
    }

    /**
     * Transform like query to js regex, and check if the corresponding element field check the constraint
     * @param {string} field the value to check on the element
     * @param {string} like the like constraint on query where options
     * @returns true if the regex match the value, either false
     * @private
     */
    checkLikeClause(field, like) {
        if (typeof like !== "string") {
            throw new Error("Like operator required an string value");
        }
        let regex = new RegExp(like.replaceAll('%', '.*'));
        return regex.test(field);
    }

    /**
     * Transform in query to js includes, and check if the corresponding element field check the constraint
     * @param {string} field the value to check on the element
     * @param {string} array the list of accepted value
     * @returns true if the value is in the array, either false
     * @private
     */
    checkInClause(field, array) {
        if (!Array.isArray(array)) {
            throw new Error("In operator required an array value");
        }
        return array.includes(field);
    }

    /**
     * Check element match schema validation before insert and update queries
     * @param {Object} element the element to check
     * @returns {Error[]} an array of error, if empty, the element passed all check
     * @private
     */
    checkFormat(element) {
        let errorStack = [];
        for (let [property, value] of Object.entries(element)) {
            if (typeof value !== this.schema[property].type.type) {
                errorStack.push(new Error("Error : property " + property + " must be of type " + this.schema[property].type.type));
            }
            if (this.schema[property].type.max &amp;&amp; value.length > this.schema[property].type.max) {
                errorStack.push(new Error("Error : property " + property + " must have " + this.schema[property].type.max + " at most"));
            }
            if (this.schema[property].unique) {
                let result = this.checkUnique(property, value);
                if (!result) {
                    errorStack.push(new Error("Error : property " + property + " must be unique"));
                }
            }
        }
        return errorStack;
    }

    /**
     * Check element match schema allowNull validation before insert and update queries
     * @param {Object} element the element to check
     * @returns {Error[]} an array of error, if empty, the element passed all allowNull check
     * @private
     */
    checkRequired(element) {
        let errorStack = [];
        let required = Array.from(this.schema).filter(property => property.required &amp;&amp; property.required === true);
        for (let [property, options] of Object.entries(required)) {
            if (!element[property]) {
                errorStack.push(new Error("Error : property " + property + " is required"));
            }
        }
        return errorStack;
    }

    /**
     * Check element match schema properties, and no other ones before insert and update queries
     * @param {Object} element the element to check
     * @returns {Error[]} an array of error, if empty, the element passed all allowNull check
     * @private
     */
    checkFieldExist(element) {
        let errorStack = [];
        for (let property of Object.keys(element)) {
            if (!this.schema[property]) {
                errorStack.push(new Error("Error : property " + property + " does not exist on " + this.name));
            }
        }
        return errorStack;
    }

    /**
     * Check element match schema unique validation before insert and update queries
     * @param {Object} element the element to check
     * @returns {boolean} true if element is unique, either false
     * @private
     */
    checkUnique(property, value) {
        let obj = {};
        obj[property] = value;
        let element = this.findOne({
            where: obj
        });
        if (element) {
            return false;
        }
        return true;
    }

    /**
     * add defaultValue on empty element before insert and update queries
     * @param {Object} element the element to check for default values
     * @private
     */
    addDefaultValue(element) {
        for (let [property, value] of Object.entries(this.schema)) {
            if (value.defaultValue &amp;&amp; !element[property]) {
                element[property] = value.defaultValue;
                console.log(element[property]);
            }
        }
    }

    /**
     * Check element match schema validators before insert and update queries
     * @param {Object} element the element to check
     * @returns {Error[]} an array of error, if empty, the element passed all validators check
     * @private
     */
    checkValidator(element) {
        let errorStack = [];
        for (let [property, value] of Object.entries(this.schema)) {
            if (value.validate) {
                errorStack = errorStack.concat(validate(element[property], property, value.validate));
            }
        }
        return errorStack;
    }
}

export default Model;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Jdb.html">Jdb</a></li><li><a href="Model.html">Model</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Fri May 02 2025 12:57:34 GMT+0200 (heure d’été d’Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
